/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE for Visual Studio Code Extension
 * @brief          : Main program body
 *
 * Modified to implement a bare-metal GPIOC13 blink (direct register access).
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "i2c.h"
#include "mpu.h"
#include "usart.h"
#include <inttypes.h> /* Include integer type header file */
#include <stdio.h>
#include <stdlib.h>

float Acc_x, Acc_y, Acc_z, Temperature, Gyro_x, Gyro_y, Gyro_z;

void
delay_ms(uint32_t ms)
{
	for (uint32_t i = 0; i < ms * 8000; i++)
		;
}

void
MPU6050_Init() /* Gyro initialization function */
{
	// Wake up MPU6050 from sleep mode
	I2C_Start(I2C1);

	// 0x68 = 1101000
	// 0xD0 = 110100001 (addr=0x68 + r/w=0) write mode
	// 0xD1 = 110100001 (addr=0x68 + r/w=1) read mode
	I2C_Addr(I2C1, 0xD0); //0x68 = 11010001       /* Start with device write address */
	I2C_Write(I2C1, PWR_MGMT_1); /* Write to power management register */
	I2C_Write(I2C1, 0x00);       /* Wake up from sleep */
	I2C_Stop(I2C1);
	delay_ms(10);

	// Set sample rate
	I2C_Start(I2C1);
	I2C_Addr(I2C1, 0xD0);
	I2C_Write(I2C1, SMPLRT_DIV); /* Write to sample rate register */
	I2C_Write(I2C1, 0x07);       /* 1KHz sample rate */
	I2C_Stop(I2C1);
	delay_ms(5);

	// Set configuration
	I2C_Start(I2C1);
	I2C_Addr(I2C1, 0xD0);
	I2C_Write(I2C1, CONFIG); /* Write to Configuration register */
	I2C_Write(I2C1, 0x00);   /* Fs = 8KHz */
	I2C_Stop(I2C1);
	delay_ms(5);

	// Set accelerometer configuration (±2g)
	I2C_Start(I2C1);
	I2C_Addr(I2C1, 0xD0);
	I2C_Write(I2C1, ACCEL_CONFIG); /* Write to Accel configuration register */
	I2C_Write(I2C1, 0x00);         /* Full scale range +/- 2g */
	I2C_Stop(I2C1);
	delay_ms(5);

	// Set gyro configuration (±250 degree/s)
	I2C_Start(I2C1);
	I2C_Addr(I2C1, 0xD0);
	I2C_Write(I2C1, GYRO_CONFIG); /* Write to Gyro configuration register */
	I2C_Write(I2C1, 0x00);        /* Full scale range +/- 250 degree/s */
	I2C_Stop(I2C1);
	delay_ms(5);

	// Enable data ready interrupt
	I2C_Start(I2C1);
	I2C_Addr(I2C1, 0xD0);
	I2C_Write(I2C1, INT_ENABLE); /* Write to interrupt enable register */
	I2C_Write(I2C1, 0x01);       /* Data ready interrupt */
	I2C_Stop(I2C1);
	delay_ms(5);
}

void
MPU_Start_Loc()
{
	// Write mode: Set register address
	I2C_Start(I2C1);
	I2C_Addr(I2C1, 0xD0);          /* Device write address */
	I2C_Write(I2C1, ACCEL_XOUT_H); /* Set start location address */
	I2C_Stop(I2C1);                /* Stop after setting address */
	delay_ms(2);

	// Read mode: Restart and read from the address
	I2C_Start(I2C1);
	I2C_Addr(I2C1, 0xD1); /* Device read address */
}

void
Read_RawValue()
{
	uint8_t byte_high, byte_low;

	MPU_Start_Loc(); /* Read Sensor values */

	// Enable ACK for reading
	I2C1->CR1 |= (1 << 10);  // Set ACK bit

	// Read Accelerometer X
	byte_high = (uint8_t)I2C_Read(I2C1);
	byte_low = (uint8_t)I2C_Read(I2C1);
	Acc_x = (int16_t)((byte_high << 8) | byte_low);

	// Read Accelerometer Y
	byte_high = (uint8_t)I2C_Read(I2C1);
	byte_low = (uint8_t)I2C_Read(I2C1);
	Acc_y = (int16_t)((byte_high << 8) | byte_low);

	// Read Accelerometer Z
	byte_high = (uint8_t)I2C_Read(I2C1);
	byte_low = (uint8_t)I2C_Read(I2C1);
	Acc_z = (int16_t)((byte_high << 8) | byte_low);

	// Read Temperature
	byte_high = (uint8_t)I2C_Read(I2C1);
	byte_low = (uint8_t)I2C_Read(I2C1);
	Temperature = (int16_t)((byte_high << 8) | byte_low);

	// Read Gyroscope X
	byte_high = (uint8_t)I2C_Read(I2C1);
	byte_low = (uint8_t)I2C_Read(I2C1);
	Gyro_x = (int16_t)((byte_high << 8) | byte_low);

	// Read Gyroscope Y
	byte_high = (uint8_t)I2C_Read(I2C1);
	byte_low = (uint8_t)I2C_Read(I2C1);
	Gyro_y = (int16_t)((byte_high << 8) | byte_low);

	// Read Gyroscope Z - last byte, send NACK
	I2C1->CR1 &= ~(1 << 10);  // Clear ACK bit for last byte
	byte_high = (uint8_t)I2C_Read(I2C1);
	byte_low = (uint8_t)I2C_Read(I2C1);
	Gyro_z = (int16_t)((byte_high << 8) | byte_low);

	I2C_Stop(I2C1);
}

int
main()
{
	char buffer[64];  // Increased buffer size for single-frame format
	float Xa, Ya, Za, t = 0;
	float Xg = 0, Yg = 0, Zg = 0;

	// Initialize I2C first
	I2CInit(I2C1, 0); /* Initialize I2C1 */
	delay_ms(100);    /* Wait for I2C to stabilize */

	usartInit(USART1, 115200, 0); /* Initialize USART */
	delay_ms(10);

	MPU6050_Init(); /* Initialize MPU6050 */
	delay_ms(100);

	while (1) {
		Read_RawValue();
		delay_ms(50); /* 50ms delay between reads */

		Xa = Acc_x / 16384.0;  // Divide raw value by sensitivity scale factor to get real values
		Ya = Acc_y / 16384.0;
		Za = Acc_z / 16384.0;

		t = Temperature / 340.0 + 36.53;  // Convert temperature to Celsius

		Xg = Gyro_x / 131.0;  // Gyro sensitivity at ±250 deg/s
		Yg = Gyro_y / 131.0;
		Zg = Gyro_z / 131.0;

		// Send all sensor data in a single frame for Raspberry Pi
		// Format: $AX,AY,AZ,TEMP,GX,GY,GZ\r\n
		snprintf(buffer, sizeof(buffer), "$%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f\r\n",
		         Xa, Ya, Za, t, Xg, Yg, Zg);
		Send_String(USART1, buffer);
	}
}